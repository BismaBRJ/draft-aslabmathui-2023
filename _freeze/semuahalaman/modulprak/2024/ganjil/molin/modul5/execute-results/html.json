{
  "hash": "1664e647bac3eb329153341ebe9bd1c1",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Studi Kasus dplyr\"\nsubtitle: \"Pre-processing dengan dplyr\"\nimage: static\\Plot regresi.png\ndescription: \"Offline di Departemen Matematika\"\ndate: 11/18/2024\npage-navigation: true\nformat:\n  html:\n    code-overflow: wrap\nknitr:\n  opts_chunk:\n    comment: ''\nformat-links: false\neditor: \n  markdown: \n    wrap: 72\n---\n\n\n\n\n# Pendahuluan\nVisualisasi adalah alat penting untuk mendapatkan wawasan, tetapi jarang sekali data yang kita miliki sudah dalam bentuk yang pas untuk membuat grafik yang kita inginkan. Sering kali, kita perlu membuat variabel baru atau meringkas data untuk menjawab pertanyaan yang ada. Kadang-kadang, kita juga mungkin ingin mengganti nama variabel atau mengatur ulang urutan data supaya lebih mudah digunakan. \n\nPada Bagian ini, kamu akan belajar cara melakukan semua itu (dan lebih banyak lagi!) dengan menggunakan package `dplyr` serta dataset baru tentang penerbangan yang berangkat dari New York City pada tahun 2013.\n\nTujuan dari bab ini adalah memberikan gambaran umum tentang alat-alat penting untuk mentransformasi data frame. Kita akan mulai dengan fungsi yang bekerja pada baris dan kolom data frame, lalu beralih membahas tentang `pipe`, alat penting untuk menggabungkan berbagai fungsi. Setelah itu, kita akan mengenalkan cara bekerja dengan kelompok data (grouping). Bagian ini akan ditutup dengan sebuah studi kasus yang menunjukkan bagaimana semua fungsi ini digunakan. \n\n## Prerequisites\n\nDi bab ini, kita akan fokus pada package `dplyr`, salah satu anggota inti dari ekosistem `tidyverse`. Kita akan menjelaskan konsep-konsep utama dengan menggunakan data dari package `nycflights13` dan memanfaatkan `ggplot2` untuk membantu memahami data tersebut.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(nycflights13)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'nycflights13' was built under R version 4.4.2\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'tidyverse' was built under R version 4.4.2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'readr' was built under R version 4.4.2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'forcats' was built under R version 4.4.2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'lubridate' was built under R version 4.4.2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n:::\n\n\n\n\n\nPerhatikan dengan baik pesan conflicts yang muncul saat kamu memuat tidyverse. Pesan ini memberitahukan bahwa `dplyr` menggantikan beberapa fungsi bawaan dari base R. Jika kamu ingin menggunakan versi fungsi bawaan setelah memuat `dplyr`, kamu perlu menuliskan nama lengkapnya, seperti `stats::filter()` dan `stats::lag()`.\n\nSelama ini, kita cenderung mengabaikan asal paket suatu fungsi karena biasanya tidak terlalu penting. Namun, mengetahui asal paket dapat membantu kamu mencari dokumentasi atau menemukan fungsi-fungsi terkait. Oleh karena itu, saat kita perlu menyebutkan asal fungsi dengan jelas, kita akan menggunakan sintaks R seperti ini: `packagename::functionname()`.\n\n## nycflights13\nUntuk mempelajari dasar-dasar verbs dalam dplyr, kita akan menggunakan dataset `nycflights13::flights`. Dataset ini mencakup semua 336.776 penerbangan yang berangkat dari New York City pada tahun 2013. Data ini berasal dari [US Bureau of Transportation Statistics](https://www.transtats.bts.gov/DL_SelectFields.aspx?gnoyr_VQ=FGJ&QO_fu146_anzr=b0-gvzr) dan dapat didokumentasikan lebih lanjut dengan menggunakan perintah `?flights`.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\n\n**flights** adalah sebuah *tibble*, yaitu tipe khusus dari data frame yang digunakan dalam `tidyverse` untuk menghindari beberapa masalah umum. Perbedaan utama antara **tibble** dan **data frame** terletak pada cara *tibble* ditampilkan. *Tibble* dirancang untuk menangani dataset besar, sehingga hanya menampilkan beberapa baris pertama dan kolom-kolom yang muat di layar.\n\nAda beberapa cara untuk melihat keseluruhan data:\n\n- Jika kamu menggunakan **RStudio** (kita memang pakai RStudio), cara paling nyaman adalah dengan menjalankan `View(flights)`, yang membuka tampilan interaktif, dapat digulir, dan dapat difilter.\n- Kamu juga bisa menggunakan `print(flights, width = Inf)` untuk menampilkan semua kolom.\n- Atau gunakan `glimpse()` untuk melihat ringkasan struktur data secara keseluruhan.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(flights)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 336,776\nColumns: 19\n$ year           <int> 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2…\n$ month          <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ day            <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ dep_time       <int> 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 558, …\n$ sched_dep_time <int> 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 600, …\n$ dep_delay      <dbl> 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2, -1…\n$ arr_time       <int> 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 849,…\n$ sched_arr_time <int> 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 851,…\n$ arr_delay      <dbl> 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7, -1…\n$ carrier        <chr> \"UA\", \"UA\", \"AA\", \"B6\", \"DL\", \"UA\", \"B6\", \"EV\", \"B6\", \"…\n$ flight         <int> 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301, 4…\n$ tailnum        <chr> \"N14228\", \"N24211\", \"N619AA\", \"N804JB\", \"N668DN\", \"N394…\n$ origin         <chr> \"EWR\", \"LGA\", \"JFK\", \"JFK\", \"LGA\", \"EWR\", \"EWR\", \"LGA\",…\n$ dest           <chr> \"IAH\", \"IAH\", \"MIA\", \"BQN\", \"ATL\", \"ORD\", \"FLL\", \"IAD\",…\n$ air_time       <dbl> 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149, 1…\n$ distance       <dbl> 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 733, …\n$ hour           <dbl> 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6…\n$ minute         <dbl> 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0…\n$ time_hour      <dttm> 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-01 0…\n```\n\n\n:::\n:::\n\n\n\n\n\nDalam kedua tampilan tersebut, nama variabel diikuti oleh singkatan yang menunjukkan tipe setiap variabel:\n\n- `<int>` berarti integer (bilangan bulat),\n- `<dbl>` berarti double (alias bilangan real),\n- `<chr>` berarti character (alias string atau teks),\n- `<dttm>` berarti date-time (tanggal dan waktu).\n\nInformasi ini penting karena operasi yang dapat dilakukan pada sebuah kolom sangat bergantung pada tipe datanya.\n\n## dplyr basics\nKamu akan mempelajari verbs utama dalam `dplyr` (fungsi-fungsi), yang dapat membantu menyelesaikan sebagian besar tantangan manipulasi data. Namun, sebelum membahas perbedaan masing-masing fungsi, ada baiknya memahami kesamaan mereka:\n\n1. Argumen pertama selalu berupa sebuah data frame.\n2. Argumen selanjutnya biasanya mendeskripsikan kolom yang akan dioperasikan, menggunakan nama variabel (tanpa tanda kutip).\n3. Hasil keluaran selalu berupa data frame baru.\n\nKarena setiap verb hanya melakukan satu tugas dengan baik, menyelesaikan masalah kompleks biasanya memerlukan kombinasi beberapa verb. Kombinasi ini dilakukan dengan menggunakan *pipe* `(|>)`.\n\nKita akan membahas pipe lebih lanjut di Bagian Asinkronus, tetapi secara singkat, pipe mengambil nilai di sebelah kirinya dan meneruskannya ke fungsi di sebelah kanannya. Contohnya:\n\n- x |> f(y) setara dengan f(x, y).\n- x |> f(y) |> g(z) setara dengan g(f(x, y), z).\nCara termudah untuk membaca pipe adalah dengan mengartikannya sebagai “then” Ini memungkinkanmu memahami maksud kode berikut meskipun belum mempelajari detailnya.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |>\n  filter(dest == \"IAH\") |> \n  group_by(year, month, day) |> \n  summarize(\n    arr_delay = mean(arr_delay, na.rm = TRUE)\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'year', 'month'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 365 × 4\n# Groups:   year, month [12]\n    year month   day arr_delay\n   <int> <int> <int>     <dbl>\n 1  2013     1     1     17.8 \n 2  2013     1     2      7   \n 3  2013     1     3     18.3 \n 4  2013     1     4     -3.2 \n 5  2013     1     5     20.2 \n 6  2013     1     6      9.28\n 7  2013     1     7     -7.74\n 8  2013     1     8      7.79\n 9  2013     1     9     18.1 \n10  2013     1    10      6.68\n# ℹ 355 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\nVerbs dalam **dplyr** dikelompokkan menjadi empat kategori berdasarkan apa yang mereka operasikan: **baris**, **kolom**, **grup**, atau **tabel**. Pada bagian berikut, kamu akan mempelajari verbs paling penting untuk mengoperasikan baris, kolom, dan grup. Kemudian, kita akan kembali membahas join verbs yang bekerja pada tabel di Bagian Asinkronus.\n\nMari kita mulai! 🚀\n\n# Rows - Baris\n\n*Verbs* paling penting yang bekerja pada baris dalam sebuah dataset adalah:\n\n1. `filter()` – Memilih baris yang akan ditampilkan tanpa mengubah urutannya.\n2. `arrange()` – Mengubah urutan baris tanpa memengaruhi baris yang ditampilkan.\nKedua fungsi ini hanya memengaruhi baris, **sementara** kolom tetap tidak berubah.\n\nSelain itu, ada juga:\n\n3. `distinct()`, yang digunakan untuk mencari baris dengan nilai yang unik. \n\nBerbeda dengan `arrange()` dan `filter()`, fungsi ini juga dapat, jika diperlukan, mengubah kolom.\n\n## filter()\n\nFungsi **filter()** memungkinkan kamu memilih baris berdasarkan nilai kolom tertentu.\n\n- Argumen pertama adalah data frame.\n- Argumen kedua dan seterusnya adalah kondisi yang harus terpenuhi agar baris tersebut dipilih.\nSebagai contoh, untuk menemukan semua penerbangan yang berangkat lebih dari 120 menit (dua jam) terlambat, kamu bisa menggunakan:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  filter(dep_delay > 120)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 9,723 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      848           1835       853     1001           1950\n 2  2013     1     1      957            733       144     1056            853\n 3  2013     1     1     1114            900       134     1447           1222\n 4  2013     1     1     1540           1338       122     2020           1825\n 5  2013     1     1     1815           1325       290     2120           1542\n 6  2013     1     1     1842           1422       260     1958           1535\n 7  2013     1     1     1856           1645       131     2212           2005\n 8  2013     1     1     1934           1725       129     2126           1855\n 9  2013     1     1     1938           1703       155     2109           1823\n10  2013     1     1     1942           1705       157     2124           1830\n# ℹ 9,713 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\nSelain operator > (lebih besar dari), kamu juga bisa menggunakan operator lain seperti:\n\n- `>=` (lebih besar atau sama dengan),\n- `<` (lebih kecil dari),\n- `<=` (lebih kecil atau sama dengan),\n- `==` (sama dengan),\n- `!=` (tidak sama dengan).\nKamu juga bisa menggabungkan beberapa kondisi:\n\nGunakan `&` atau tanda koma (`,`) untuk menunjukkan and (kedua kondisi harus terpenuhi).\nGunakan `|` untuk menunjukkan `or` (salah satu kondisi cukup terpenuhi).\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Flights that departed on January 1\nflights |> \n  filter(month == 1 & day == 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 842 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 832 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n\n```{.r .cell-code}\n# Flights that departed in January or February\nflights |> \n  filter(month == 1 | month == 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 51,955 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 51,945 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\n\nAda sebuah shortcut yang berguna saat kamu menggabungkan `|` dengan `==`, yaitu operator `%in%`. Operator ini akan memilih baris di mana sebuah variabel sama dengan salah satu nilai yang ada di sebelah kanan.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A shorter way to select flights that departed in January or February\nflights |> \n  filter(month %in% c(1, 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 51,955 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 51,945 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\n\nSaat kamu menjalankan **filter(), dplyr** melakukan operasi pemfilteran, membuat *data frame* baru, lalu mencetak hasilnya. Namun, fungsi **dplyr** *tidak pernah* mengubah dataset yang ada, termasuk dataset **flights.**\n\nJika kamu ingin menyimpan hasilnya, kamu harus menggunakan operator penugasan `<-`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\njan1 <- flights |> \n  filter(month == 1 & day == 1)\n```\n:::\n\n\n\n\n\n## common mistakes\nKetika baru mulai belajar R, salah satu kesalahan paling umum adalah menggunakan = alih-alih == untuk menguji kesetaraan.\n\n- `=` digunakan untuk penugasan, bukan untuk membandingkan nilai.\n- `==` digunakan untuk memeriksa apakah dua nilai sama.\nJika kamu secara tidak sengaja menggunakan `=` di dalam `filter()`, R akan memberikan pesan kesalahan yang membantu kamu mengenali kesalahan ini.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  filter(month == 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 27,004 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 26,994 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\n\nKesalahan umum lainnya adalah menulis pernyataan *\"or\"* seperti dalam bahasa Inggris, alih-alih mengikuti sintaks R.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  filter(month == 1 | 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\n\nKode tersebut tidak akan menghasilkan kesalahan tetapi juga tidak akan melakukan apa yang kamu inginkan. Masalahnya adalah operator `|` pertama-tama akan memeriksa kondisi `month == 1` dan kemudian memeriksa nilai 2 sebagai kondisi, yang sebenarnya tidak masuk akal untuk diperiksa.\n\nKenapa tidak masuk akal? Karena R mencoba memeriksa apakah nilai 2 itu benar atau salah (logical value), dan ini tidak relevan dengan kolom month.\n\n::: {.callout-caution collapse=\"true\"}\n\n### Bagi yang belum mengerti\n\nSecara **intuisi** kita ingin mengambil bulan Januari atau (`|`) bulan Februari (Keduanya boleh). Tetapi, Perhatikan kalau konjungsi dan disjungsi dalam bahasa R ini proposisi atomik-nya harus berupa syntax `callable`.\n\nPerhatikan perbedaan kedua hal ini.\n\n- `filter(month == 1 | 2)`\n- `filter(month == 1 | day == 2)`\n\nNanti, ketika syntax di atas dicompile, maka ia akan mengecek conditional_value dari kedua proposisi atomik di atas.\n\n- Yang pertama ia akan mengecek apakah `row` ke-i memiliki nilai `month` adalah `1` atau tidak. Jika `month == 1` maka proposisi atomik ruas kiri akan bernilai `TRUE`. Lalu, ia akan cek proposisi kanan operator `or` yakni 2. Ia akan menentukan apakan 2 ini `TRUE` atau `FALSE`. Akan tetapi, karena ia tidak merupakan coditional, ia tidak dapat ditentukan apakah 2 ini `TRUE` atau `FALSE`.\n- Yang kedua sama, kecuali pada proposisi atomik yang sebelah kanan, dapat ditentukan conditional_value miliknya.\n\nPerhatikan hal ini juga berlaku (bahkan lebih **worst** logika-nya [tidak masuk akal]) pada kasus konjungsi.\n\n- `filter(month == 1 & 2)`\n\n:::\n\n## arrange()\nFungsi `arrange()` digunakan untuk mengubah urutan baris dalam dataset berdasarkan nilai-nilai pada kolom-kolom yang diberikan. Fungsi ini menerima sebuah data frame dan satu set nama kolom (atau ekspresi yang lebih rumit) yang akan digunakan untuk menentukan urutan.\n\nJika kamu memberikan lebih dari satu nama kolom, kolom tambahan akan digunakan untuk memecahkan *tie* (nilai yang sama) pada kolom sebelumnya. Dengan kata lain, jika dua baris memiliki nilai yang sama di kolom pertama, `arrange()` akan memeriksa kolom kedua untuk menentukan urutan.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  arrange(year, month, day, dep_time)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\n\nApa yang terjadi di sini?\n\n- Penerbangan akan diurutkan pertama berdasarkan tahun.\n- Jika ada penerbangan di tahun yang sama, maka urutan dilanjutkan berdasarkan bulan.\n- Kemudian berdasarkan hari dalam bulan tersebut.\n- Terakhir, penerbangan yang terjadi pada hari yang sama akan diurutkan berdasarkan waktu keberangkatan (dep_time).\nDengan cara ini, kita mendapatkan urutan penerbangan dari yang paling awal hingga yang paling terlambat, dimulai dari tahun yang paling awal.\n\nUntuk mengurutkan data berdasarkan kolom dalam urutan menurun (dari yang besar ke kecil), kamu dapat menggunakan fungsi `desc()` di dalam `arrange()`. Fungsi `desc()` mengubah urutan kolom yang kamu tentukan sehingga data akan diurutkan dari nilai terbesar ke terkecil.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  arrange(desc(dep_delay))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     9      641            900      1301     1242           1530\n 2  2013     6    15     1432           1935      1137     1607           2120\n 3  2013     1    10     1121           1635      1126     1239           1810\n 4  2013     9    20     1139           1845      1014     1457           2210\n 5  2013     7    22      845           1600      1005     1044           1815\n 6  2013     4    10     1100           1900       960     1342           2211\n 7  2013     3    17     2321            810       911      135           1020\n 8  2013     6    27      959           1900       899     1236           2226\n 9  2013     7    22     2257            759       898      121           1026\n10  2013    12     5      756           1700       896     1058           2020\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\n\nPerhatikan bahwa jumlah baris tidak berubah – kami hanya mengatur data, kami tidak memfilternya.\n\n## distinct()\nFungsi `distinct()` di *dplyr* digunakan untuk mencari dan mengembalikan baris-baris unik dalam sebuah dataset. Secara teknis, fungsi ini bekerja pada baris (**rows**) karena akan menghapus baris yang duplikat. Namun, lebih sering daripada itu, kamu mungkin ingin mencari kombinasi unik dari beberapa kolom tertentu dalam dataset, bukan seluruh baris.\n\nKamu bisa memberikan satu atau lebih nama kolom ke dalam `distinct()` untuk mendapatkan kombinasi unik dari kolom-kolom tersebut. Berikut adalah contoh penggunaannya:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Remove duplicate rows, if any\nflights |> \n  distinct()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n\n```{.r .cell-code}\n# Find all unique origin and destination pairs\nflights |> \n  distinct(origin, dest)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 224 × 2\n   origin dest \n   <chr>  <chr>\n 1 EWR    IAH  \n 2 LGA    IAH  \n 3 JFK    MIA  \n 4 JFK    BQN  \n 5 LGA    ATL  \n 6 EWR    ORD  \n 7 EWR    FLL  \n 8 LGA    IAD  \n 9 JFK    MCO  \n10 LGA    ORD  \n# ℹ 214 more rows\n```\n\n\n:::\n:::\n\n\n\n\nJika kamu ingin menjaga kolom-kolom lain saat mencari baris unik, kamu dapat menggunakan opsi `.keep_all = TRUE` dalam fungsi `distinct()`. Opsi ini memungkinkan kamu untuk mengembalikan seluruh kolom dalam dataset, bukan hanya kolom yang digunakan untuk menentukan keunikan.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  distinct(origin, dest, .keep_all = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 224 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 214 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\nPenjelasan:\n\n- origin dan dest adalah kolom yang digunakan untuk menentukan keunikan.\n- Dengan menambahkan `.keep_all = TRUE`, fungsi **distinct()** akan mengembalikan seluruh baris yang unik berdasarkan kombinasi origin dan dest, tetapi tetap menyertakan semua kolom lainnya dalam dataset (seperti **dep_delay, arr_delay,** dll.).\n\nBukan kebetulan bahwa semua penerbangan berbeda ini terjadi pada 1 Januari: `distinct()` akan menemukan kemunculan pertama dari baris unik dalam kumpulan data dan membuang sisanya.\n\nJika Anda ingin menemukan jumlah kemunculan, Anda lebih baik menukar `distinct()` dengan `count()`. Dengan argumen `sort = TRUE`, Anda dapat mengaturnya dalam urutan menurun dari jumlah kemunculan.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |>\n  count(origin, dest, sort = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 224 × 3\n   origin dest      n\n   <chr>  <chr> <int>\n 1 JFK    LAX   11262\n 2 LGA    ATL   10263\n 3 LGA    ORD    8857\n 4 JFK    SFO    8204\n 5 LGA    CLT    6168\n 6 EWR    ORD    6100\n 7 JFK    BOS    5898\n 8 LGA    MIA    5781\n 9 JFK    MCO    5464\n10 EWR    BOS    5327\n# ℹ 214 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n### Latihan 1\n1. Dalam satu alur(in a single pipeline) untuk setiap kondisi, temukan semua penerbangan yang memenuhi kondisi tersebut:\n\n  - Memiliki penundaan kedatangan dua jam atau lebih\n  - Terbang ke Houston (IAH atau HOU)\n  - Dioperasikan oleh United, American, atau Delta\n  - Berangkat pada musim panas (Juli, Agustus, dan September)\n  - Tiba lebih dari dua jam terlambat tetapi tidak pulang terlambat\n  - Ditunda setidaknya satu jam, tetapi dibuat lebih dari 30 menit dalam penerbangan\n\n2. Urutkan penerbangan untuk menemukan penerbangan dengan penundaan keberangkatan terlama. Temukan penerbangan yang berangkat paling awal di pagi hari.\n\n3. Urutkan penerbangan untuk menemukan penerbangan tercepat. (Petunjuk: Coba sertakan perhitungan matematika di dalam fungsi Anda.)\n\n4. Apakah ada penerbangan setiap hari di tahun 2013?\n\n5. Penerbangan mana yang menempuh jarak terjauh? Mana yang menempuh jarak paling sedikit?\n\n6. Apakah penting urutan apa yang Anda gunakan `filter()` dan `arrange()` jika Anda menggunakan keduanya? Mengapa tidak? Pikirkan tentang hasil dan berapa banyak pekerjaan yang harus dilakukan oleh fungsi tersebut.\n\n::: {.callout-note icon=false}\n\n## Pay Attention\n\nCoba kerjakan dahulu sendiri. Jawaban tersedia [disini](jawabanLatihanModul5-1.qmd)\n\n:::\n\n# Columns - Kolom\nAda empat kata kerja penting yang memengaruhi kolom tanpa mengubah baris: `mutate()` membuat kolom baru yang diturunkan dari kolom yang ada, `select()` mengubah kolom mana yang ada, `rename()` mengubah nama kolom, dan `relocate()` mengubah posisi kolom.\n\n## mutate()\nTugas `mutate()` adalah menambahkan kolom baru yang dihitung dari kolom yang ada. Dalam bab transform, Anda akan mempelajari sekumpulan besar fungsi yang dapat Anda gunakan untuk memanipulasi berbagai jenis variabel. Untuk saat ini, kita akan tetap menggunakan aljabar dasar, yang memungkinkan kita menghitung perolehan, berapa lama waktu penerbangan yang tertunda di udara, dan kecepatan dalam mil per jam:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  mutate(\n    gain = dep_delay - arr_delay,\n    speed = distance / air_time * 60\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 21\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 13 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>, gain <dbl>, speed <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n\nSecara default, `mutate()` menambahkan kolom baru di sisi kanan kumpulan data Anda, yang menyulitkan untuk melihat apa yang terjadi di sini. Kita bisa menggunakan `.` sebelum argumen untuk menambahkan variabel ke sisi kiri 2:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  mutate(\n    gain = dep_delay - arr_delay,\n    speed = distance / air_time * 60,\n    .before = 1\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 21\n    gain speed  year month   day dep_time sched_dep_time dep_delay arr_time\n   <dbl> <dbl> <int> <int> <int>    <int>          <int>     <dbl>    <int>\n 1    -9  370.  2013     1     1      517            515         2      830\n 2   -16  374.  2013     1     1      533            529         4      850\n 3   -31  408.  2013     1     1      542            540         2      923\n 4    17  517.  2013     1     1      544            545        -1     1004\n 5    19  394.  2013     1     1      554            600        -6      812\n 6   -16  288.  2013     1     1      554            558        -4      740\n 7   -24  404.  2013     1     1      555            600        -5      913\n 8    11  259.  2013     1     1      557            600        -3      709\n 9     5  405.  2013     1     1      557            600        -3      838\n10   -10  319.  2013     1     1      558            600        -2      753\n# ℹ 336,766 more rows\n# ℹ 12 more variables: sched_arr_time <int>, arr_delay <dbl>, carrier <chr>,\n#   flight <int>, tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>,\n#   distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\n`.` menunjukkan bahwa `.before` adalah argumen untuk fungsi tersebut, bukan nama variabel baru ketiga yang sedang kita buat. Anda juga dapat menggunakan `.after` menambahkan setelah variabel, dan di keduanya `.before` dan `.after` Anda dapat menggunakan nama variabel alih-alih posisi. Misalnya, kita dapat menambahkan variabel baru setelah `day`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  mutate(\n    gain = dep_delay - arr_delay,\n    speed = distance / air_time * 60,\n    .after = day\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 21\n    year month   day  gain speed dep_time sched_dep_time dep_delay arr_time\n   <int> <int> <int> <dbl> <dbl>    <int>          <int>     <dbl>    <int>\n 1  2013     1     1    -9  370.      517            515         2      830\n 2  2013     1     1   -16  374.      533            529         4      850\n 3  2013     1     1   -31  408.      542            540         2      923\n 4  2013     1     1    17  517.      544            545        -1     1004\n 5  2013     1     1    19  394.      554            600        -6      812\n 6  2013     1     1   -16  288.      554            558        -4      740\n 7  2013     1     1   -24  404.      555            600        -5      913\n 8  2013     1     1    11  259.      557            600        -3      709\n 9  2013     1     1     5  405.      557            600        -3      838\n10  2013     1     1   -10  319.      558            600        -2      753\n# ℹ 336,766 more rows\n# ℹ 12 more variables: sched_arr_time <int>, arr_delay <dbl>, carrier <chr>,\n#   flight <int>, tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>,\n#   distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\nSebagai alternatif, kamu bisa mengontrol variabel mana saja yang ingin disimpan menggunakan argumen `.keep`. Salah satu nilai yang berguna untuk `.keep` adalah `\"used\"`, yang artinya kita hanya menyimpan kolom-kolom yang terlibat atau dibuat dalam langkah `mutate()`. Misalnya, pada kode berikut, hasilnya hanya akan berisi variabel-variabel: `dep_delay`, `arr_delay`, `air_time`, `gain`, `hours`, dan `gain_per_hour`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  mutate(\n    gain = dep_delay - arr_delay,\n    hours = air_time / 60,\n    gain_per_hour = gain / hours,\n    .keep = \"used\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 6\n   dep_delay arr_delay air_time  gain hours gain_per_hour\n       <dbl>     <dbl>    <dbl> <dbl> <dbl>         <dbl>\n 1         2        11      227    -9 3.78          -2.38\n 2         4        20      227   -16 3.78          -4.23\n 3         2        33      160   -31 2.67         -11.6 \n 4        -1       -18      183    17 3.05           5.57\n 5        -6       -25      116    19 1.93           9.83\n 6        -4        12      150   -16 2.5           -6.4 \n 7        -5        19      158   -24 2.63          -9.11\n 8        -3       -14       53    11 0.883         12.5 \n 9        -3        -8      140     5 2.33           2.14\n10        -2         8      138   -10 2.3           -4.35\n# ℹ 336,766 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n::: {.callout-note appearance=\"simple\"}\n\n## Pay Attention\n\nkita belum menetapkan hasil perhitungan di atas kembali ke `flights`, variabel baru `gain`, `hours`, dan `gain_per_hour` hanya akan dicetak tetapi tidak akan disimpan dalam `data frame`. \n\nDan jika kita ingin hasilnya tersedia dalam `data frame` untuk penggunaan di masa mendatang, kita harus memikirkan dengan cermat apakah kita ingin hasilnya ditetapkan kembali ke `flights`, menimpa `data frame` asli dengan lebih banyak variabel, atau ke objek baru. \n\nSeringkali, jawaban yang benar adalah objek baru yang diberi nama secara informatif untuk menunjukkan isinya, mis., `delay_gain`, tetapi Anda mungkin juga memiliki alasan bagus untuk menimpa `flights`.\n\n:::\n\n## select()\nTidak jarang mendapatkan kumpulan data dengan ratusan atau bahkan ribuan variabel. Dalam situasi ini, tantangan pertama seringkali hanya berfokus pada variabel yang Anda minati. `select()` memungkinkan Anda memperbesar subset yang berguna dengan cepat menggunakan operasi berdasarkan nama variabel:\n\n- Select columns by name:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  select(year, month, day)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 3\n    year month   day\n   <int> <int> <int>\n 1  2013     1     1\n 2  2013     1     1\n 3  2013     1     1\n 4  2013     1     1\n 5  2013     1     1\n 6  2013     1     1\n 7  2013     1     1\n 8  2013     1     1\n 9  2013     1     1\n10  2013     1     1\n# ℹ 336,766 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n- Select all columns between year and day (inclusive):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  select(year:day)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 3\n    year month   day\n   <int> <int> <int>\n 1  2013     1     1\n 2  2013     1     1\n 3  2013     1     1\n 4  2013     1     1\n 5  2013     1     1\n 6  2013     1     1\n 7  2013     1     1\n 8  2013     1     1\n 9  2013     1     1\n10  2013     1     1\n# ℹ 336,766 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n- Select all columns except those from year to day (inclusive):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  select(!year:day)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 16\n   dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier\n      <int>          <int>     <dbl>    <int>          <int>     <dbl> <chr>  \n 1      517            515         2      830            819        11 UA     \n 2      533            529         4      850            830        20 UA     \n 3      542            540         2      923            850        33 AA     \n 4      544            545        -1     1004           1022       -18 B6     \n 5      554            600        -6      812            837       -25 DL     \n 6      554            558        -4      740            728        12 UA     \n 7      555            600        -5      913            854        19 B6     \n 8      557            600        -3      709            723       -14 EV     \n 9      557            600        -3      838            846        -8 B6     \n10      558            600        -2      753            745         8 AA     \n# ℹ 336,766 more rows\n# ℹ 9 more variables: flight <int>, tailnum <chr>, origin <chr>, dest <chr>,\n#   air_time <dbl>, distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\nSecara historis, operasi ini dilakukan dengan `-` alih-alih `!`, jadi kemungkinan besar Anda akan melihatnya di luar sana (*wild*). Kedua operator ini memiliki tujuan yang sama tetapi dengan perbedaan perilaku yang tidak kentara. \n\n::: {.callout-tip}\n## Rekomendasi\nKami merekomendasikan penggunaan `!` karena terbaca sebagai \"no\" dan berpadu dengan baik dengan `&` dan `|`.\n:::\n\n- Select all columns that are characters:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  select(where(is.character))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 4\n   carrier tailnum origin dest \n   <chr>   <chr>   <chr>  <chr>\n 1 UA      N14228  EWR    IAH  \n 2 UA      N24211  LGA    IAH  \n 3 AA      N619AA  JFK    MIA  \n 4 B6      N804JB  JFK    BQN  \n 5 DL      N668DN  LGA    ATL  \n 6 UA      N39463  EWR    ORD  \n 7 B6      N516JB  EWR    FLL  \n 8 EV      N829AS  LGA    IAD  \n 9 B6      N593JB  JFK    MCO  \n10 AA      N3ALAA  LGA    ORD  \n# ℹ 336,766 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\nAda beberapa fungsi bantu (helper functions) yang dapat kamu gunakan di dalam `select()` untuk memilih kolom berdasarkan pola nama tertentu:\n\n- starts_with(\"abc\"): Memilih nama kolom yang diawali dengan \"abc\".\nContoh: Kolom bernama abc_data atau abc_result.\n\n- ends_with(\"xyz\"): Memilih nama kolom yang diakhiri dengan \"xyz\".\nContoh: Kolom bernama value_xyz atau output_xyz.\n\n- contains(\"ijk\"): Memilih nama kolom yang mengandung \"ijk\".\nContoh: Kolom bernama data_ijk atau ijk_value.\n\n- num_range(\"x\", 1:3): Memilih nama kolom dengan pola x1, x2, dan x3.\nCocok untuk kolom yang diberi nama dengan format angka berurutan.\n\nLihat dokumentasi `?select` untuk informasi lebih lanjut. Setelah kamu memahami ekspresi reguler (yang akan dibahas di Bagian asinkronus), kamu juga bisa menggunakan fungsi `matches()` untuk memilih variabel yang sesuai dengan pola tertentu.\n\nAnda dapat mengganti nama variabel saat Anda `select()` dengan menggunakan `=`. Nama baru muncul di sisi kiri `=`, dan variabel lama muncul di sisi kanan:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  select(tail_num = tailnum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 1\n   tail_num\n   <chr>   \n 1 N14228  \n 2 N24211  \n 3 N619AA  \n 4 N804JB  \n 5 N668DN  \n 6 N39463  \n 7 N516JB  \n 8 N829AS  \n 9 N593JB  \n10 N3ALAA  \n# ℹ 336,766 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n## rename()\nJika Anda ingin menyimpan semua variabel yang ada dan hanya ingin mengganti nama beberapa variabel, Anda dapat menggunakan `rename()` alih-alih `select()`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  rename(tail_num = tailnum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tail_num <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\n\nJika kamu memiliki banyak kolom dengan nama yang tidak konsisten dan memperbaikinya satu per satu akan memakan waktu, coba gunakan [`janitor::clean_names()`](https://sfirke.github.io/janitor/reference/clean_names.html), yang dapat membersihkan nama-nama kolom secara otomatis dengan cara yang berguna.\n\n## relocate()\n\nGunakan `relocate()` untuk memindahkan variabel di dalam dataset. Kamu mungkin ingin mengumpulkan variabel-variabel yang berhubungan bersama atau memindahkan variabel penting ke depan. Secara default, `relocate()` akan memindahkan variabel ke bagian depan dataset.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  relocate(time_hour, air_time)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n   time_hour           air_time  year month   day dep_time sched_dep_time\n   <dttm>                 <dbl> <int> <int> <int>    <int>          <int>\n 1 2013-01-01 05:00:00      227  2013     1     1      517            515\n 2 2013-01-01 05:00:00      227  2013     1     1      533            529\n 3 2013-01-01 05:00:00      160  2013     1     1      542            540\n 4 2013-01-01 05:00:00      183  2013     1     1      544            545\n 5 2013-01-01 06:00:00      116  2013     1     1      554            600\n 6 2013-01-01 05:00:00      150  2013     1     1      554            558\n 7 2013-01-01 06:00:00      158  2013     1     1      555            600\n 8 2013-01-01 06:00:00       53  2013     1     1      557            600\n 9 2013-01-01 06:00:00      140  2013     1     1      557            600\n10 2013-01-01 06:00:00      138  2013     1     1      558            600\n# ℹ 336,766 more rows\n# ℹ 12 more variables: dep_delay <dbl>, arr_time <int>, sched_arr_time <int>,\n#   arr_delay <dbl>, carrier <chr>, flight <int>, tailnum <chr>, origin <chr>,\n#   dest <chr>, distance <dbl>, hour <dbl>, minute <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n\nAnda juga dapat menentukan di mana harus meletakkannya menggunakan `.before` dan `.after` argumen, seperti di `mutate()`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  relocate(year:dep_time, .after = time_hour)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n   sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier flight\n            <int>     <dbl>    <int>          <int>     <dbl> <chr>    <int>\n 1            515         2      830            819        11 UA        1545\n 2            529         4      850            830        20 UA        1714\n 3            540         2      923            850        33 AA        1141\n 4            545        -1     1004           1022       -18 B6         725\n 5            600        -6      812            837       -25 DL         461\n 6            558        -4      740            728        12 UA        1696\n 7            600        -5      913            854        19 B6         507\n 8            600        -3      709            723       -14 EV        5708\n 9            600        -3      838            846        -8 B6          79\n10            600        -2      753            745         8 AA         301\n# ℹ 336,766 more rows\n# ℹ 12 more variables: tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>,\n#   distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>, year <int>,\n#   month <int>, day <int>, dep_time <int>\n```\n\n\n:::\n\n```{.r .cell-code}\nflights |> \n  relocate(starts_with(\"arr\"), .before = dep_time)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day arr_time arr_delay dep_time sched_dep_time dep_delay\n   <int> <int> <int>    <int>     <dbl>    <int>          <int>     <dbl>\n 1  2013     1     1      830        11      517            515         2\n 2  2013     1     1      850        20      533            529         4\n 3  2013     1     1      923        33      542            540         2\n 4  2013     1     1     1004       -18      544            545        -1\n 5  2013     1     1      812       -25      554            600        -6\n 6  2013     1     1      740        12      554            558        -4\n 7  2013     1     1      913        19      555            600        -5\n 8  2013     1     1      709       -14      557            600        -3\n 9  2013     1     1      838        -8      557            600        -3\n10  2013     1     1      753         8      558            600        -2\n# ℹ 336,766 more rows\n# ℹ 11 more variables: sched_arr_time <int>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\n\n##Latihan 2\n1. Bandingkan `dep_time`, `sched_dep_time`, dan `dep_delay.` Bagaimana Anda mengharapkan ketiga angka itu terkait?\n\n2. Lakukan brainstorming sebanyak mungkin cara untuk memilih `dep_time`, `dep_delay`, `arr_time`, dan `arr_delay` dari `flights`.\n\n3. Apa yang terjadi jika Anda menentukan nama variabel yang sama beberapa kali dalam panggilan `select()`?\n\n4. Apa yang dilakukan fungsi `any_of()`? Mengapa ini bisa membantu dalam hubungannya dengan vektor ini?\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvariables <- c(\"year\", \"month\", \"day\", \"dep_delay\", \"arr_delay\")\n```\n:::\n\n\n\n\n5. Apakah hasil menjalankan kode berikut mengejutkan Anda? Bagaimana pembantu select menangani huruf besar dan kecil secara default? Bagaimana Anda bisa mengubah default itu?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> select(contains(\"TIME\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 6\n   dep_time sched_dep_time arr_time sched_arr_time air_time time_hour          \n      <int>          <int>    <int>          <int>    <dbl> <dttm>             \n 1      517            515      830            819      227 2013-01-01 05:00:00\n 2      533            529      850            830      227 2013-01-01 05:00:00\n 3      542            540      923            850      160 2013-01-01 05:00:00\n 4      544            545     1004           1022      183 2013-01-01 05:00:00\n 5      554            600      812            837      116 2013-01-01 06:00:00\n 6      554            558      740            728      150 2013-01-01 05:00:00\n 7      555            600      913            854      158 2013-01-01 06:00:00\n 8      557            600      709            723       53 2013-01-01 06:00:00\n 9      557            600      838            846      140 2013-01-01 06:00:00\n10      558            600      753            745      138 2013-01-01 06:00:00\n# ℹ 336,766 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n6. Ganti nama `air_time` menjadi `air_time_min` untuk menunjukkan satuan pengukuran dan memindahkannya ke awal bingkai data.\n\nMengapa hal berikut tidak berhasil, dan apa arti kesalahannya?\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  select(tailnum) |> \n  arrange(arr_delay)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `arrange()`:\nℹ In argument: `..1 = arr_delay`.\nCaused by error:\n! object 'arr_delay' not found\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-note icon=false}\n\n## Pay Attention\n\nCoba kerjakan dahulu sendiri. Jawaban tersedia [disini](jawabanLatihanModul5-2.qmd)\n\n:::\n\n## The pipe\nKami telah menunjukkan contoh sederhana dari penggunaan pipe di atas, namun kekuatan sebenarnya dari pipe muncul saat kamu mulai menggabungkan beberapa fungsi (verbs). Misalnya, bayangkan kamu ingin mencari penerbangan tercepat ke bandara IAH di Houston. Untuk melakukan ini, kamu perlu menggabungkan fungsi `filter()`, `mutate()`, `select()`, dan `arrange()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  filter(dest == \"IAH\") |> \n  mutate(speed = distance / air_time * 60) |> \n  select(year:day, dep_time, carrier, flight, speed) |> \n  arrange(desc(speed))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7,198 × 7\n    year month   day dep_time carrier flight speed\n   <int> <int> <int>    <int> <chr>    <int> <dbl>\n 1  2013     7     9      707 UA         226  522.\n 2  2013     8    27     1850 UA        1128  521.\n 3  2013     8    28      902 UA        1711  519.\n 4  2013     8    28     2122 UA        1022  519.\n 5  2013     6    11     1628 UA        1178  515.\n 6  2013     8    27     1017 UA         333  515.\n 7  2013     8    27     1205 UA        1421  515.\n 8  2013     8    27     1758 UA         302  515.\n 9  2013     9    27      521 UA         252  515.\n10  2013     8    28      625 UA         559  515.\n# ℹ 7,188 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\nMeskipun alur ini memiliki empat langkah, mudah untuk membaca sekilas karena kata kerja muncul di awal setiap baris: mulai dengan data `flights`, lalu filter, lalu mutate, lalu select, lalu arrange.\n\nApa yang akan terjadi jika kita tidak memiliki `pipe`? Kita dapat menyarangkan setiap pemanggilan fungsi di dalam pemanggilan sebelumnya:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\narrange(\n  select(\n    mutate(\n      filter(\n        flights, \n        dest == \"IAH\"\n      ),\n      speed = distance / air_time * 60\n    ),\n    year:day, dep_time, carrier, flight, speed\n  ),\n  desc(speed)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7,198 × 7\n    year month   day dep_time carrier flight speed\n   <int> <int> <int>    <int> <chr>    <int> <dbl>\n 1  2013     7     9      707 UA         226  522.\n 2  2013     8    27     1850 UA        1128  521.\n 3  2013     8    28      902 UA        1711  519.\n 4  2013     8    28     2122 UA        1022  519.\n 5  2013     6    11     1628 UA        1178  515.\n 6  2013     8    27     1017 UA         333  515.\n 7  2013     8    27     1205 UA        1421  515.\n 8  2013     8    27     1758 UA         302  515.\n 9  2013     9    27      521 UA         252  515.\n10  2013     8    28      625 UA         559  515.\n# ℹ 7,188 more rows\n```\n\n\n:::\n:::\n\n\n\n\nAtau kita bisa menggunakan banyak objek perantara:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights1 <- filter(flights, dest == \"IAH\")\nflights2 <- mutate(flights1, speed = distance / air_time * 60)\nflights3 <- select(flights2, year:day, dep_time, carrier, flight, speed)\narrange(flights3, desc(speed))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7,198 × 7\n    year month   day dep_time carrier flight speed\n   <int> <int> <int>    <int> <chr>    <int> <dbl>\n 1  2013     7     9      707 UA         226  522.\n 2  2013     8    27     1850 UA        1128  521.\n 3  2013     8    28      902 UA        1711  519.\n 4  2013     8    28     2122 UA        1022  519.\n 5  2013     6    11     1628 UA        1178  515.\n 6  2013     8    27     1017 UA         333  515.\n 7  2013     8    27     1205 UA        1421  515.\n 8  2013     8    27     1758 UA         302  515.\n 9  2013     9    27      521 UA         252  515.\n10  2013     8    28      625 UA         559  515.\n# ℹ 7,188 more rows\n```\n\n\n:::\n:::\n\n\n\n\nMeskipun kedua bentuk (menggunakan `pipe` atau tanpa `pipe`) memiliki kelebihan dan kekurangannya masing-masing, penggunaan `pipe` umumnya menghasilkan kode analisis data yang lebih mudah ditulis dan dibaca.\n\n#### Kenapa Pipe Lebih Baik?\n- Kemudahan Membaca: Kode yang menggunakan pip lebih mudah dibaca karena setiap langkah dalam proses analisis data dipecah menjadi bagian yang terpisah, dan urutannya jelas. Ini membuat alur logika lebih transparan.\n- Kemudahan Menulis: Dengan pipe, kita tidak perlu menulis fungsi-fungsi bersarang yang dapat membingungkan. Kode lebih ringkas dan mudah dimodifikasi.\n\n#### Menambahkan Pipe ke Kode:\nDi RStudio, kamu bisa menambahkan pipe dengan menggunakan shortcut keyboard bawaan Ctrl/Cmd + Shift + M. Ini akan menyisipkan simbol pipe (|>) secara otomatis ke dalam kode kamu.\n\n![Gambar 1. Untuk memasukkan |>, pastikan “Use native pipe operator” option is checked.](./static/shortcut-pipe.png)\n\n::: {.callout-caution collapse=\"true\"}\n#### Perbedaan Antara `%>%` dan `|>`:\n- %>%: Ini adalah operator pipe yang umum digunakan di `dplyr` dan berbagai paket `tidyverse` lainnya. Ini juga berfungsi dalam banyak situasi di luar `tidyverse`.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#|eval: FALSE\nlibrary(tidyverse)\n\nmtcars %>% \n  group_by(cyl) %>%\n  summarize(n = n())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n    cyl     n\n  <dbl> <int>\n1     4    11\n2     6     7\n3     8    14\n```\n\n\n:::\n:::\n\n\n\n\n\n- |>: Operator pipe ini adalah bagian dari bahasa R itu sendiri, mulai diperkenalkan di R versi 4.1.0. Fungsinya mirip dengan `%>%`, tetapi memiliki beberapa perbedaan kecil dalam cara menangani argumen dan kedalaman fungsi.\n:::\n\n## Groups\nSejauh ini Anda telah mempelajari tentang fungsi yang berfungsi dengan baris dan kolom. dplyr menjadi lebih kuat saat Anda menambahkan kemampuan untuk bekerja dengan grup. Di bagian ini, kita akan fokus pada fungsi yang paling penting: `group_by()`, `summarize()` dan keluarga fungsi slice.\n\n## group_by()\nGunakan `group_by()` untuk membagi kumpulan data Anda menjadi beberapa grup yang bermakna untuk analisis Anda:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  group_by(month)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\n`group_by()` tidak mengubah data tetapi, jika Anda melihat lebih dekat pada outputnya, Anda akan melihat bahwa outputnya menunjukkan bahwa itu \"dikelompokkan berdasarkan\" bulan (`Groups: month [12]`). Ini berarti operasi selanjutnya sekarang akan berfungsi \"berdasarkan bulan\". `group_by()` menambahkan fitur yang dikelompokkan ini (disebut sebagai kelas *class*) ke `data frame`, yang mengubah perilaku kata kerja berikutnya yang diterapkan ke data.\n\n## summarize()\nOperasi pengelompokan yang paling penting adalah ringkasan, yang mana jika digunakan untuk menghitung statistik ringkasan tunggal, mengurangi data frame menjadi satu baris untuk setiap grup. Di `dplyr`, operasi ini dilakukan dengan `summarize()`, seperti yang ditunjukkan oleh contoh berikut, yang menghitung penundaan keberangkatan rata-rata menurut bulan:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  group_by(month) |> \n  summarize(\n    avg_delay = mean(dep_delay)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 2\n   month avg_delay\n   <int>     <dbl>\n 1     1        NA\n 2     2        NA\n 3     3        NA\n 4     4        NA\n 5     5        NA\n 6     6        NA\n 7     7        NA\n 8     8        NA\n 9     9        NA\n10    10        NA\n11    11        NA\n12    12        NA\n```\n\n\n:::\n:::\n\n\n\n\n\nUh-oh! Ada yang tidak beres, dan semua hasil kami adalah `NAs` (diucapkan \"NA\"), simbol R untuk nilai yang hilang. Ini terjadi karena beberapa penerbangan yang diamati memiliki data yang hilang di kolom penundaan, jadi ketika kami menghitung rata-rata termasuk nilai tersebut, kami mendapatkan hasil `NA`. Kita akan kembali membahas nilai yang hilang secara detail di Bagian Asinkronus, tetapi untuk saat ini, kita akan memberi tahu fungsi `mean()` untuk mengabaikan semua nilai yang hilang dengan menyetel argumen `na.rm` menjadi `TRUE`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  group_by(month) |> \n  summarize(\n    avg_delay = mean(dep_delay, na.rm = TRUE)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 2\n   month avg_delay\n   <int>     <dbl>\n 1     1     10.0 \n 2     2     10.8 \n 3     3     13.2 \n 4     4     13.9 \n 5     5     13.0 \n 6     6     20.8 \n 7     7     21.7 \n 8     8     12.6 \n 9     9      6.72\n10    10      6.24\n11    11      5.44\n12    12     16.6 \n```\n\n\n:::\n:::\n\n\n\n\n\nAnda dapat membuat sejumlah ringkasan dalam satu panggilan ke summarize(). Anda akan mempelajari berbagai ringkasan berguna di bab-bab mendatang, tetapi satu ringkasan yang sangat berguna adalah n(), yang mengembalikan jumlah baris di setiap grup:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  group_by(month) |> \n  summarize(\n    avg_delay = mean(dep_delay, na.rm = TRUE), \n    n = n()\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 3\n   month avg_delay     n\n   <int>     <dbl> <int>\n 1     1     10.0  27004\n 2     2     10.8  24951\n 3     3     13.2  28834\n 4     4     13.9  28330\n 5     5     13.0  28796\n 6     6     20.8  28243\n 7     7     21.7  29425\n 8     8     12.6  29327\n 9     9      6.72 27574\n10    10      6.24 28889\n11    11      5.44 27268\n12    12     16.6  28135\n```\n\n\n:::\n:::\n\n\n\n\n\nMeans dan counts bisa ditemukan lebih lanjut dalam ilmu data!\n\n## The sclice function\n\nBerikut adalah lima fungsi berguna dalam `dplyr` yang memungkinkan kamu untuk mengekstrak baris tertentu dalam setiap grup:\n\n- slice_head(n = 1): Mengambil baris pertama dari setiap grup.\n- slice_tail(n = 1): Mengambil baris terakhir dari setiap grup.\n- slice_min(x, n = 1): Mengambil baris dengan nilai terkecil di kolom x.\n- slice_max(x, n = 1): Mengambil baris dengan nilai terbesar di kolom x.\n- slice_sample(n = 1): Mengambil satu baris secara acak.\n\nKamu dapat menyesuaikan n untuk memilih lebih dari satu baris, atau kamu bisa menggunakan argumen prop untuk memilih proporsi tertentu dari baris. Misalnya, `prop = 0.1` akan memilih 10% dari baris di setiap grup.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  group_by(dest) |> \n  slice_max(arr_delay, n = 1) |>\n  relocate(dest)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 108 × 19\n# Groups:   dest [105]\n   dest   year month   day dep_time sched_dep_time dep_delay arr_time\n   <chr> <int> <int> <int>    <int>          <int>     <dbl>    <int>\n 1 ABQ    2013     7    22     2145           2007        98      132\n 2 ACK    2013     7    23     1139            800       219     1250\n 3 ALB    2013     1    25      123           2000       323      229\n 4 ANC    2013     8    17     1740           1625        75     2042\n 5 ATL    2013     7    22     2257            759       898      121\n 6 AUS    2013     7    10     2056           1505       351     2347\n 7 AVL    2013     8    13     1156            832       204     1417\n 8 BDL    2013     2    21     1728           1316       252     1839\n 9 BGR    2013    12     1     1504           1056       248     1628\n10 BHM    2013     4    10       25           1900       325      136\n# ℹ 98 more rows\n# ℹ 11 more variables: sched_arr_time <int>, arr_delay <dbl>, carrier <chr>,\n#   flight <int>, tailnum <chr>, origin <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\nPerhatikan bahwa meskipun ada 105 tujuan, kita mendapatkan 108 baris di sini. Mengapa bisa begitu?\n\nFungsi `slice_min()` dan `slice_max()` akan mempertahankan nilai yang terikat (tie), jadi meskipun kita menetapkan `n = 1`, jika ada beberapa baris dengan nilai yang sama (misalnya, keterlambatan yang sama), maka seluruh baris tersebut akan dimasukkan. Jika kamu hanya ingin satu baris per grup meskipun ada nilai yang terikat, kamu bisa menggunakan argumen `with_ties = FALSE`.\n\nDengan menambahkan `with_ties` = `FALSE`, fungsi ini hanya akan mengambil satu baris per grup, bahkan jika ada beberapa baris yang memiliki nilai keterlambatan yang sama.\n\nIni mirip dengan perhitungan nilai maksimum menggunakan `summarize()`, tetapi dengan `slice_max()` atau `slice_min()`, kamu mendapatkan seluruh baris yang sesuai dengan nilai tersebut (atau beberapa baris jika ada tie), bukan hanya statistik ringkasan tunggal.\n\n## Grouping by multiple variables\nAnda dapat membuat grup menggunakan lebih dari satu variabel. Misalnya, kita dapat membuat grup untuk setiap tanggal.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndaily <- flights |>  \n  group_by(year, month, day)\ndaily\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n# Groups:   year, month, day [365]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\nKetika kamu melakukan *summary* pada sebuah tibble yang dikelompokkan berdasarkan lebih dari satu variabel, setiap *summary* akan memisahkan grup terakhir. Meskipun ini bukan cara terbaik untuk membuat fungsi ini bekerja, perubahan pada perilaku ini sulit dilakukan tanpa merusak kode yang sudah ada.\n\nUntuk membuat hal ini lebih jelas, `dplyr` menampilkan pesan yang memberi tahu kamu bagaimana cara mengubah perilaku ini. Pesan tersebut biasanya berbunyi seperti ini:\n\n\"This is the default behavior of **summarize()** when grouping by multiple variables. To change this behavior, you can use **group_by()** followed by **ungroup()** or adjust the grouping inside **summarize()**.\"\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndaily_flights <- daily |> \n  summarize(n = n())\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'year', 'month'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n:::\n\n\n\n\nJika Anda *happy* dengan perilaku ini, Anda dapat memintanya secara eksplisit untuk menyembunyikan pesan tersebut:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndaily_flights <- daily |> \n  summarize(\n    n = n(), \n    .groups = \"drop_last\"\n  )\n```\n:::\n\n\n\n\nAtau, ubah perilaku default dengan menetapkan nilai yang berbeda, mis., \"drop\" untuk menghapus semua pengelompokan atau \"keep\" untuk mempertahankan grup yang sama.\n\n## Ungrouping\nAnda mungkin juga ingin menghapus pengelompokan dari dataframe tanpa menggunakan `summarize()`. Anda dapat melakukannya dengan `ungroup()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndaily |> \n  ungroup()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\nSekarang mari kita lihat apa yang terjadi saat Anda summarize data frame yang tidak dikelompokkan.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndaily |> \n  ungroup() |>\n  summarize(\n    avg_delay = mean(dep_delay, na.rm = TRUE), \n    flights = n()\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  avg_delay flights\n      <dbl>   <int>\n1      12.6  336776\n```\n\n\n:::\n:::\n\n\n\n\nAnda mendapatkan satu baris kembali karena `dplyr` memperlakukan semua baris dalam data frame yang tidak dikelompokkan sebagai milik satu grup.\n\n## .by\n`dplyr` `1.1.0` menyertakan sintaks baru, eksperimental, untuk pengelompokan per operasi, argumen `.by`, `group_by()`, dan `ungroup()` tidak akan hilang, tetapi sekarang Anda juga dapat menggunakan argumen `.by` untuk mengelompokkan dalam satu operasi:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  summarize(\n    delay = mean(dep_delay, na.rm = TRUE), \n    n = n(),\n    .by = month\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 3\n   month delay     n\n   <int> <dbl> <int>\n 1     1 10.0  27004\n 2    10  6.24 28889\n 3    11  5.44 27268\n 4    12 16.6  28135\n 5     2 10.8  24951\n 6     3 13.2  28834\n 7     4 13.9  28330\n 8     5 13.0  28796\n 9     6 20.8  28243\n10     7 21.7  29425\n11     8 12.6  29327\n12     9  6.72 27574\n```\n\n\n:::\n:::\n\n\n\n\nAtau jika Anda ingin mengelompokkan berdasarkan beberapa variabel:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  summarize(\n    delay = mean(dep_delay, na.rm = TRUE), \n    n = n(),\n    .by = c(origin, dest)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 224 × 4\n   origin dest  delay     n\n   <chr>  <chr> <dbl> <int>\n 1 EWR    IAH   11.8   3973\n 2 LGA    IAH    9.06  2951\n 3 JFK    MIA    9.34  3314\n 4 JFK    BQN    6.67   599\n 5 LGA    ATL   11.4  10263\n 6 EWR    ORD   14.6   6100\n 7 EWR    FLL   13.5   3793\n 8 LGA    IAD   16.7   1803\n 9 JFK    MCO   10.6   5464\n10 LGA    ORD   10.7   8857\n# ℹ 214 more rows\n```\n\n\n:::\n:::\n\n\n\n\n`.by` bekerja dengan semua kata kerja dan memiliki keuntungan bahwa Anda tidak perlu menggunakan argumen `.group` untuk menekan pesan pengelompokan atau `ungroup()` setelah selesai.\n\n## Latihan 3\n\n1. Operator mana yang memiliki penundaan rata-rata terburuk? Tantangan: dapatkah Anda menguraikan efek dari bad airport v.s. bad carriers? Mengapa iya / mengapa tidak? (Petunjuk: pikirkan tentang `flights`|> group_by(carrier, dest)|> summarize(n()))\n\n2. Temukan penerbangan yang paling tertunda saat keberangkatan dari setiap tujuan.\n\n3. Bagaimana penundaan bervariasi sepanjang hari? Ilustrasikan jawaban Anda dengan sebuah plot.\n\n4. Apa yang terjadi jika Anda memberikan n negatif ke `slice_min()` dan teman-temannya?\n\n5. Jelaskan apa yang dilakukan count() dalam kaitannya dengan kata kerja `dplyr` yang baru saja Anda pelajari. Apa yang dilakukan argumen `sort` kepada `count()`?\n\n6. Misalkan kita memiliki bingkai data kecil berikut:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(\n  x = 1:5,\n  y = c(\"a\", \"b\", \"a\", \"a\", \"b\"),\n  z = c(\"K\", \"K\", \"L\", \"L\", \"K\")\n)\n```\n:::\n\n\n\n\n  a. Tuliskan seperti apa tampilan outputnya menurut Anda, lalu periksa apakah Anda benar, dan jelaskan apa yang dilakukan `group_by()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  group_by(y)\n```\n:::\n\n\n\n\n\n  b. Tuliskan seperti apa tampilan outputnya menurut Anda, lalu periksa apakah Anda benar, dan jelaskan apa yang dilakukan `arrange()`. Juga, beri komentar tentang perbedaannya dari `group_by()` di bagian (a).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  arrange(y)\n```\n:::\n\n\n\n\n\n  c. Tuliskan seperti apa tampilan outputnya menurut Anda, lalu periksa apakah Anda benar, dan jelaskan apa yang dilakukan pipeline.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  group_by(y) |>\n  summarize(mean_x = mean(x))\n```\n:::\n\n\n\n\n\n  d. Tuliskan seperti apa tampilan outputnya menurut Anda, lalu periksa apakah Anda benar, dan jelaskan apa yang dilakukan pipeline. Kemudian, komentari apa yang dikatakan pesan tersebut.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  group_by(y, z) |>\n  summarize(mean_x = mean(x))\n```\n:::\n\n\n\n\n\n  e. Tuliskan seperti apa tampilan outputnya menurut Anda, lalu periksa apakah Anda benar, dan jelaskan apa yang dilakukan pipeline. Bagaimana outputnya berbeda dari yang ada di bagian (d)?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  group_by(y, z) |>\n  summarize(mean_x = mean(x), .groups = \"drop\")\n```\n:::\n\n\n\n\n\n  f. Tuliskan seperti apa tampilan outputnya menurut Anda, lalu periksa apakah Anda benar, dan jelaskan apa yang dilakukan setiap pipeline. Bagaimana output dari kedua pipeline berbeda?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  group_by(y, z) |>\n  summarize(mean_x = mean(x))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'y'. You can override using the `.groups`\nargument.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n# Groups:   y [2]\n  y     z     mean_x\n  <chr> <chr>  <dbl>\n1 a     K        1  \n2 a     L        3.5\n3 b     K        3.5\n```\n\n\n:::\n\n```{.r .cell-code}\ndf |>\n  group_by(y, z) |>\n  mutate(mean_x = mean(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 4\n# Groups:   y, z [3]\n      x y     z     mean_x\n  <int> <chr> <chr>  <dbl>\n1     1 a     K        1  \n2     2 b     K        3.5\n3     3 a     L        3.5\n4     4 a     L        3.5\n5     5 b     K        3.5\n```\n\n\n:::\n:::\n\n\n\n\n\n::: {.callout-note icon=false}\n\n## Pay Attention\n\nCoba kerjakan dahulu sendiri. Jawaban tersedia [disini](jawabanLatihanModul5-3.qmd)\n\n:::\n\n# Studi kasus - Dataset Information\n\nKita akan memberikan salah satu contoh pemula *pre-processing* dari data yang dibawah ini.\n\n## Pendahuluan\n\nDalam dunia transportasi online, layanan seperti greb telah mengubah\ncara kita memesan dan menggunakan transportasi. Seiring dengan\npertumbuhan pesat teknologi, data yang dihasilkan oleh platform\ntransportasi online semakin berharga. Untuk memanfaatkan potensi data\nini, kami mengadakan kompetisi prediksi harga pesanan mobil. Tujuan dari\nkompetisi ini adalah untuk mengembangkan model prediksi yang akurat dan\ncanggih untuk harga pesanan mobil berdasarkan fitur-fitur yang\ndiberikan.\n\n## Evaluation\n\nDalam kasus kali ini, kami akan menggunakan Root Mean Square Error\n(RMSE) sebagai metrik evaluasi utama untuk mengukur kinerja model\nprediksi harga pesanan mobil. RMSE mengukur sejauh mana prediksi harga\nyang dihasilkan oleh model mendekati harga aktual.\n\nRMSE didefinisikan sebagai berikut:\n\n$$\\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} (y_i - \\hat{y}_i)^2}$$ Hasil RMSE\nyang lebih rendah menunjukkan kinerja model yang lebih baik dalam\nmemprediksi harga pesanan mobil. Peserta yang berhasil menghasilkan\nmodel dengan RMSE terendah akan diberi apresiasi.\n\n## Scoring System\n\nDalam kasus kali ini, penilaian akan dinilai 100% dari metrik, dimana\npenilaian kalian akan bergantung pada evaluasi metrik. Semakin rendah\nhasil RMSE kalian, semakin tinggi poin yang akan kalian peroleh.\n\n## Penjelasan Dataset\n\n| Column Name   | Description                                            |\n|---------------|--------------------------------------------------------|\n| timestamp     | Memberikan informasi berupa waktu atau penanda.        |\n| api_calls     | Mencerminkan jumlah panggilan atau permintaan ke API.  |\n| clouds        | Memberikan informasi tentang kondisi awan.             |\n| distance_max  | Menggambarkan jarak terkait pesanan (jarak maksimum).  |\n| distance_mean | Menggambarkan jarak terkait pesanan (jarak rata-rata). |\n| distance_min  | Menggambarkan jarak terkait pesanan (jarak minimum).   |\n| humidity      | Menunjukkan tingkat kelembapan.                        |\n| rain          | Data terkait hujan atau curah hujan.                   |\n| surge_max     | Informasi lonjakan harga (lonjakan maksimum).          |\n| surge_mean    | Informasi lonjakan harga (lonjakan rata-rata).         |\n| surge_min     | Informasi lonjakan harga (lonjakan minimum).           |\n| temp          | Data terkait suhu.                                     |\n| price_mean    | Harga pesanan mobil                                    |\n\n# Main Notebook\n\n## Import Data\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain <- read.csv('https://raw.githubusercontent.com/zzeiidann/Ristek-UI-Competition/refs/heads/main/Ristek-UI-Data-Competition-2023/Data/train.csv')\ntest <- read.csv('https://raw.githubusercontent.com/zzeiidann/Ristek-UI-Competition/refs/heads/main/Ristek-UI-Data-Competition-2023/Data/test.csv')\n```\n:::\n\n\n\n\n\n-   `train` : digunakan untuk melatih model , sekaligus mengevaluasi\n    model.\n-   `test` : digunakan untuk membuat prediksi menggunakan model setelah\n    selesai dibuat.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(train)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            timestamp api_calls    clouds distance_max distance_mean\n1 2018-11-26 06:00:00         9 0.9906667         3.03      1.726667\n2 2018-11-26 07:00:00        10 0.9700000         2.67      1.690000\n3 2018-11-26 08:00:00         1 0.9800000         1.38      1.380000\n4 2018-11-26 09:00:00        11 1.0000000         3.08      1.920909\n5 2018-11-26 10:00:00        12 0.9950000         3.01      2.122500\n6 2018-11-26 11:00:00         6 0.9550000         2.97      1.721667\n  distance_min  humidity price_mean rain surge_max surge_mean surge_min\n1         1.04 0.9133333   16.55556    0      1.50   1.055556         1\n2         1.09 0.9200000   17.30000    0      2.00   1.100000         1\n3         1.38 0.9233333   13.50000    0      1.00   1.000000         1\n4         1.39 0.9275000   17.95455    0      1.75   1.113636         1\n5         1.07 0.9400000   18.62500    0      1.50   1.083333         1\n6         1.03 0.9400000   15.08333    0      1.00   1.000000         1\n      temp     wind type\n1 40.62733 1.350667    0\n2 41.13750 1.735000    0\n3 40.92000 1.330000    0\n4 40.93750 1.365000    0\n5 40.69500 1.895000    0\n6 40.18500 2.260000    0\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(test)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  index           timestamp api_calls clouds distance_max distance_mean\n1     0 2018-12-14 00:00:00        13   0.69         3.02      1.980000\n2     1 2018-12-14 01:00:00        14   0.77         2.34      1.541429\n3     2 2018-12-14 02:00:00        13   0.59         3.00      2.010769\n4     3 2018-12-14 03:00:00        12   0.68         3.14      1.860833\n5     4 2018-12-14 04:00:00         7   0.72         2.41      1.634286\n6     5 2018-12-14 05:00:00         9   0.60         2.63      1.623333\n  distance_min humidity rain surge_max surge_mean surge_min  temp wind type\n1         1.06     0.68    0      2.00   1.115385         1 29.93 1.99    0\n2         1.04     0.68    0      1.00   1.000000         1 30.19 2.35    0\n3         1.08     0.69    0      1.50   1.096154         1 30.02 1.98    0\n4         1.06     0.70    0      1.25   1.020833         1 29.89 1.92    0\n5         1.06     0.71    0      1.25   1.035714         1 29.92 1.58    0\n6         1.06     0.73    0      1.25   1.027778         1 29.28 1.35    0\n```\n\n\n:::\n:::\n\n\n\n\n\n## Collecting Data Information\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat('Informasi Data Train')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nInformasi Data Train\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(train)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t20355 obs. of  15 variables:\n $ timestamp    : chr  \"2018-11-26 06:00:00\" \"2018-11-26 07:00:00\" \"2018-11-26 08:00:00\" \"2018-11-26 09:00:00\" ...\n $ api_calls    : num  9 10 1 11 12 6 12 9 9 10 ...\n $ clouds       : num  0.991 0.97 0.98 1 0.995 ...\n $ distance_max : num  3.03 2.67 1.38 3.08 3.01 2.97 3.01 3.01 3.02 3.03 ...\n $ distance_mean: num  1.73 1.69 1.38 1.92 2.12 ...\n $ distance_min : num  1.04 1.09 1.38 1.39 1.07 1.03 1.07 1.06 1.04 1.07 ...\n $ humidity     : num  0.913 0.92 0.923 0.927 0.94 ...\n $ price_mean   : num  16.6 17.3 13.5 18 18.6 ...\n $ rain         : num  0 0 0 0 0 0 0 0.0031 0.0044 0 ...\n $ surge_max    : num  1.5 2 1 1.75 1.5 1 1.25 2 1 1 ...\n $ surge_mean   : num  1.06 1.1 1 1.11 1.08 ...\n $ surge_min    : num  1 1 1 1 1 1 1 1 1 1 ...\n $ temp         : num  40.6 41.1 40.9 40.9 40.7 ...\n $ wind         : num  1.35 1.74 1.33 1.36 1.9 ...\n $ type         : int  0 0 0 0 0 0 0 0 0 0 ...\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncat('Informasi Data Test')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nInformasi Data Test\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(test)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t11040 obs. of  15 variables:\n $ index        : int  0 1 2 3 4 5 6 7 8 9 ...\n $ timestamp    : chr  \"2018-12-14 00:00:00\" \"2018-12-14 01:00:00\" \"2018-12-14 02:00:00\" \"2018-12-14 03:00:00\" ...\n $ api_calls    : num  13 14 13 12 7 9 17 9 11 15 ...\n $ clouds       : num  0.69 0.77 0.59 0.68 0.72 0.6 0.6 0.34 0.53 0.44 ...\n $ distance_max : num  3.02 2.34 3 3.14 2.41 2.63 2.32 3.16 3.05 3.01 ...\n $ distance_mean: num  1.98 1.54 2.01 1.86 1.63 ...\n $ distance_min : num  1.06 1.04 1.08 1.06 1.06 1.06 1.01 1.06 1.06 1.06 ...\n $ humidity     : num  0.68 0.68 0.69 0.7 0.71 0.73 0.73 0.77 0.77 0.81 ...\n $ rain         : num  0 0 0 0 0 0 0 0 0 0 ...\n $ surge_max    : num  2 1 1.5 1.25 1.25 1.25 1 1 2 1.5 ...\n $ surge_mean   : num  1.12 1 1.1 1.02 1.04 ...\n $ surge_min    : num  1 1 1 1 1 1 1 1 1 1 ...\n $ temp         : num  29.9 30.2 30 29.9 29.9 ...\n $ wind         : num  1.99 2.35 1.98 1.92 1.58 1.35 0.83 2.48 3.12 2.39 ...\n $ type         : int  0 0 0 0 0 0 0 0 0 0 ...\n```\n\n\n:::\n:::\n\n\n\n\n\nDapat dilihat bahwa `timestamp` masih memiliki data type yang salah.\nSehingga kita harus memastikan semua variabel yang kita miliki sesuai\ndata type yang seharusnya. Oleh karena itu , pada bagian ini kita akan\nmemperbaiki data type `timestamp` tersebut.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain$timestamp <- as.Date(train$timestamp, format = \"%Y-%m-%d\")\nstr(train$timestamp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Date[1:20355], format: \"2018-11-26\" \"2018-11-26\" \"2018-11-26\" \"2018-11-26\" \"2018-11-26\" ...\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntest$timestamp <- as.Date(test$timestamp, format = \"%Y-%m-%d\")\nstr(test$timestamp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Date[1:11040], format: \"2018-12-14\" \"2018-12-14\" \"2018-12-14\" \"2018-12-14\" \"2018-12-14\" ...\n```\n\n\n:::\n:::\n\n\n\n\n\n## Missing Value Checking and Handling\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolSums(is.na(train))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    timestamp     api_calls        clouds  distance_max distance_mean \n            0             0           192             0             0 \n distance_min      humidity    price_mean          rain     surge_max \n            0           192             0           192             0 \n   surge_mean     surge_min          temp          wind          type \n            0             0           192           192             0 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat('Jumlah total Missing Value :' , sum(is.na(train)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nJumlah total Missing Value : 960\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolSums(is.na(test))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        index     timestamp     api_calls        clouds  distance_max \n            0             0             0             0             0 \ndistance_mean  distance_min      humidity          rain     surge_max \n            0             0             0             0             0 \n   surge_mean     surge_min          temp          wind          type \n            0             0             0             0             0 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat('Jumlah total Missing Value :' , sum(is.na(test)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nJumlah total Missing Value : 0\n```\n\n\n:::\n:::\n\n\n\n\n\nDapat dilihat dari hasil sebelumnya bahwa terdapat missing value pada\nbeberapa kolom. Sehingga kita perlu menentukan apakah kita akan handling\nmissing value ini dengan `imputasi` atau menghapus observasi / row dari\nmissing value tersebut. Pada kesempatan kali ini kita akan mengimputasi\nmissing value tersebut.\n\nTipe Tipe Imputasi :\n\n| Skala Data | Metode Imputasi | Contoh |\n|------------------|----------------------|--------------------------------|\n| Categorical | Buat NA Menjadi class baru. | Umur (Balita = 1 , Dewasa = 2, Lansia = 3) |\n| Numerical (continous) | Mean, Median, Mode. | Umur (14,16,17,19,20,24,50,60) |\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"tidyverse\")\ninstall.packages(\"dplyr\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(conflicted)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'conflicted' was built under R version 4.4.2\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain <- train %>%\n  mutate(clouds = replace_na(clouds, mean(clouds, na.rm = TRUE)))\n\nsum(is.na(train$clouds))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain <- train %>%\n mutate(humidity = replace_na(humidity, mean(humidity, na.rm = TRUE)))\n  \ntrain <- train %>%\n  mutate(rain = replace_na(rain, mean(rain, na.rm = TRUE)))\n  \ntrain <- train %>%\n  mutate(temp = replace_na(temp, mean(temp, na.rm = TRUE)))\n  \n train <- train %>%\n  mutate(wind = replace_na(wind, mean(wind, na.rm = TRUE)))  \n```\n:::\n\n\n\n\n\nSetelah semua missing value diisi jangan lupa untuk recheck kembali data\nyang sudah diimputasi (Tujuannya adalah untuk memastikan kolom yang\nmissing sudah ter isi)\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolSums(is.na(train))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    timestamp     api_calls        clouds  distance_max distance_mean \n            0             0             0             0             0 \n distance_min      humidity    price_mean          rain     surge_max \n            0             0             0             0             0 \n   surge_mean     surge_min          temp          wind          type \n            0             0             0             0             0 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat('Jumlah total Missing Value :' , sum(is.na(train)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nJumlah total Missing Value : 0\n```\n\n\n:::\n:::\n\n\n\n\n\n## Duplicated Data Detection\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat('Jumlah Observasi yang duplikat pada data train:', sum(duplicated(train)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nJumlah Observasi yang duplikat pada data train: 0\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncat('Jumlah Observasi yang duplikat pada data test:', sum(duplicated(test)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nJumlah Observasi yang duplikat pada data test: 0\n```\n\n\n:::\n:::\n\n\n\n\n\nBerdasarkan hasil yang diperoleh tidak terdapat data yang duplikat pada\ndata train dan test.\n",
    "supporting": [
      "modul5_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}