{
  "hash": "04abd0178b21b2cd7a4286df97142fa0",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Pertemuan 1: Aljabar Matriks di R\"\nsubtitle: \"Pengantar Multivariat\"\nimage: static\\latsol.png\ndescription: \"Offline di Departemen Matematika\"\ndate: 09/24/2024\npage-navigation: true\nformat: html\n---\n\n\n# Notasi Matrix di R\n\nUntuk membuat suatu matrix di R, gunakan fungsi \n\n`matrix(<values>, nrow=<jumlah baris>, ncol=<jumlah kolom>, byrow=TRUE/FALSE)`\n\nArgumen `byrow` digunakan untuk mengatur apakah matrix **disusun per baris atau per kolom**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(c(1,2,4,1,1,0,1,1,2), nrow=3, ncol=3, byrow=TRUE) # byrow=TRUE -> disusun per baris\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    2    4\n[2,]    1    1    0\n[3,]    1    1    2\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(c(1,2,4,1,1,0,1,1,2), nrow=3, ncol=3, byrow=FALSE) # byrow=FALSE -> disusun per kolom\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    1    1\n[2,]    2    1    1\n[3,]    4    0    2\n```\n\n\n:::\n:::\n\n\nTiap baris dan kolom dapat diberikan nama dengan argumen `dimnames=list(rownames, colnames)`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Matriks disusun per baris diberikan nama\nrownames = c(\"row1\", \"row2\", \"row3\")\ncolnames = c(\"col1\", \"col2\", \"col3\")\nA <- matrix(c(1,2,4,1,1,0,1,1,2), nrow=3, ncol=3, byrow=TRUE, dimnames=list(rownames, colnames))\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     col1 col2 col3\nrow1    1    2    4\nrow2    1    1    0\nrow3    1    1    2\n```\n\n\n:::\n:::\n\n\n## Dataframe to Matrix\n\nUntuk mengubah suat dataframe menjadi matrix, dapat digunakan fungsi `as.matrix()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(iris)\ndata <- head(iris[, c('Sepal.Length', 'Sepal.Width')])\nmat_data <- as.matrix(data)\nmat_data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width\n1          5.1         3.5\n2          4.9         3.0\n3          4.7         3.2\n4          4.6         3.1\n5          5.0         3.6\n6          5.4         3.9\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t6 obs. of  2 variables:\n $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4\n $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(mat_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n num [1:6, 1:2] 5.1 4.9 4.7 4.6 5 5.4 3.5 3 3.2 3.1 ...\n - attr(*, \"dimnames\")=List of 2\n  ..$ : chr [1:6] \"1\" \"2\" \"3\" \"4\" ...\n  ..$ : chr [1:2] \"Sepal.Length\" \"Sepal.Width\"\n```\n\n\n:::\n:::\n\n\n# Operasi Matrix\n\n## Penjumlahan dan Pengurangan\n\nOperasi penjumlahan dan pengurangan pada matriks dapat dilakukan layaknya operasi penjumlahan dan pengurangan pada skalar di R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(c(1,1,2,3,1,1,4,1,3), ncol=3, byrow=T)\nB <- matrix(c(1,2,3,1,1,4,5,6,7), ncol=3, byrow=T)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    1    2\n[2,]    3    1    1\n[3,]    4    1    3\n```\n\n\n:::\n\n```{.r .cell-code}\nB\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    1    1    4\n[3,]    5    6    7\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nA + B\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    2    3    5\n[2,]    4    2    5\n[3,]    9    7   10\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nA - B\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    0   -1   -1\n[2,]    2    0   -3\n[3,]   -1   -5   -4\n```\n\n\n:::\n:::\n\n\n## Perkalian Matriks dengan Skalar\n\nOperasi perkalian pada matriks dapat dilakukan layaknya operasi perkalian pada skalar di R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(c(1,1,3,2,1,4), ncol=3, byrow=T)\nk <- 2\n\nk * A\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    2    2    6\n[2,]    4    2    8\n```\n\n\n:::\n:::\n\n\n## Perkalian Matriks dengan Matriks\n\nOperasi perkalian matriks dengan matriks harus menggunakan tanda `%*%`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(c(1,1,1,1,2,1), ncol=3, byrow=T)\nB <- matrix(c(2,1,1,2,3,1), nrow=3, byrow=T)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    1    1\n[2,]    1    2    1\n```\n\n\n:::\n\n```{.r .cell-code}\nB\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    2    1\n[2,]    1    2\n[3,]    3    1\n```\n\n\n:::\n\n```{.r .cell-code}\nA %*% B\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    6    4\n[2,]    7    6\n```\n\n\n:::\n:::\n\n\n::: {.callout-warning}\n## Hadamard Product (Element-wise Multiplication)\n\nMelakukan perkalian matriks dengan matriks tanpa menggunakan tanda `%` akan melakukan operator lain, yaitu ***Hadamard Product***\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(c(2,0,-1,4,1,3), ncol=3, byrow=T)\nB <- matrix(c(1,3,7,2,0,6), ncol=3, byrow=T)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    2    0   -1\n[2,]    4    1    3\n```\n\n\n:::\n\n```{.r .cell-code}\nB\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    3    7\n[2,]    2    0    6\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nA * B\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    2    0   -7\n[2,]    8    0   18\n```\n\n\n:::\n:::\n\n\n:::\n\n## Transpose\n\nTranspose matriks dapat dilakukan dengan fungsi `t()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(c(1,1,3,5,2,1,1,0,1,2,3,5), ncol=4, byrow=T)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    1    3    5\n[2,]    2    1    1    0\n[3,]    1    2    3    5\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nt(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    2    1\n[2,]    1    1    2\n[3,]    3    1    3\n[4,]    5    0    5\n```\n\n\n:::\n:::\n\n\n## Trace\n\nUntuk penghitungan trace, diperlukan library `matlib` dengan fungsi `tr()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(matlib)\nA <- matrix(c(1,7,6,8,3,9,4,-2,-8), ncol=3, byrow=T)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    7    6\n[2,]    8    3    9\n[3,]    4   -2   -8\n```\n\n\n:::\n\n```{.r .cell-code}\ntr(A) # 1 + 3 - 8 = -4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -4\n```\n\n\n:::\n:::\n\n\n## Determinan\n\nDeterminan matriks dapat dihitung dengan fungsi `det()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(c(1,3,2,8,17,21,2,7,1), ncol=3, byrow=T)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    3    2\n[2,]    8   17   21\n[3,]    2    7    1\n```\n\n\n:::\n\n```{.r .cell-code}\ndet(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 16\n```\n\n\n:::\n:::\n\n\n## Invers\n\nInvers matriks **A** dapat dihitung dengan fungsi `solve(A)`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(c(1,3,2,8,17,21,2,7,1), ncol=3, byrow=T)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    3    2\n[2,]    8   17   21\n[3,]    2    7    1\n```\n\n\n:::\n\n```{.r .cell-code}\nsolve(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       [,1]    [,2]    [,3]\n[1,] -8.125  0.6875  1.8125\n[2,]  2.125 -0.1875 -0.3125\n[3,]  1.375 -0.0625 -0.4375\n```\n\n\n:::\n:::\n\n\n## Power Matrix\n\nMatriks **A**^n dapat dihitung dengan operator `A %^% n`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(expm)\nn <- 3\nA <- matrix(c(1,1,2,3,1,1,4,1,3), ncol=3, byrow=T)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    1    2\n[2,]    3    1    1\n[3,]    4    1    3\n```\n\n\n:::\n\n```{.r .cell-code}\nA %^% n\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]   60   25   55\n[2,]   65   25   55\n[3,]  115   45  100\n```\n\n\n:::\n:::\n\n\n::: {.callout-warning}\n\n## Batasan n pada A %^% n Power Matrix\n\nPower matrix dalam fungsi dari library `expm` ini mengasumsikan nilai n adalah bilangan bulat positif. Jika ingin menggunakan nilai n non bilangan bulat positif.\n\n:::\n\n## Square Root Matrix\n\nDari library `expm`, dapat dicari akar kuadrat dari suatu matrix dengan fungsi `sqrtm`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrtm(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                     [,1]                 [,2]                 [,3]\n[1,] 0.7996281+0.7653010i 0.3420350-0.1942727i 0.6718684-0.3063164i\n[2,] 1.0505083-0.7472764i 0.8850394+0.1896972i 0.2688254+0.2991019i\n[3,] 1.3315353-0.5304036i 0.2932286+0.1346437i 1.5081014+0.2122973i\n```\n\n\n:::\n:::\n\n\nBukti:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(Re(sqrtm(A) %*% sqrtm(A)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    1    2\n[2,]    3    1    1\n[3,]    4    1    3\n```\n\n\n:::\n:::\n\n\n## Matriks Identitas\n\nMatriks identitas n x n dapat dengan mudah dibuat menggunakan fungsi `diag(n)`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiag_mat <- diag(5)\ndiag_mat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    0    0    0    0\n[2,]    0    1    0    0    0\n[3,]    0    0    1    0    0\n[4,]    0    0    0    1    0\n[5,]    0    0    0    0    1\n```\n\n\n:::\n:::\n\n\n## Vektor\n\nNotasi vektor sama dengan membuat suatu matriks dengan `ncol=1`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- matrix(c(1,0,2), ncol=1, byrow=T)\ny <- matrix(c(2,2,1), ncol=1, byrow=T)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]\n[1,]    1\n[2,]    0\n[3,]    2\n```\n\n\n:::\n\n```{.r .cell-code}\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]\n[1,]    2\n[2,]    2\n[3,]    1\n```\n\n\n:::\n:::\n\n\n### Inner Product\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(t(x) %*% y) # bentuk skalar dan simetri\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]\n[1,]    4\n```\n\n\n:::\n:::\n\n\n### Outer Product\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(x %*% t(y)) # tidak bersifat simetri\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    2    2    1\n[2,]    0    0    0\n[3,]    4    4    2\n```\n\n\n:::\n:::\n\n\n## Rank Matriks\n\nUntuk menghitung rank matriks, dibutuhkan library `Matrix` dengan fungsi `rankMatrix()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(Matrix)\nA <- matrix(c(5,-14,2,-10,-5,-10,10,2,-4), ncol=3, byrow=T)\nrankMatrix(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\nattr(,\"method\")\n[1] \"tolNorm2\"\nattr(,\"useGrad\")\n[1] FALSE\nattr(,\"tol\")\n[1] 6.661338e-16\n```\n\n\n:::\n:::\n\n\n## Bentuk Eselon Baris\n\nUntuk membuat bentuk eselon baris suatu matriks, dibutuhkan library `matlib` dengan fungsi `echelon()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(c(-1,2,0,4,5,-3,3,-7,2,0,1,4,2,-5,2,4,6,1,4,-9,2,-4,-4,7), ncol=6, byrow=T)\nechelon(A, reduced = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    0   -4  -28  -37   13\n[2,]    0    1   -2  -12  -16    5\n[3,]    0    0    0    0    0    0\n[4,]    0    0    0    0    0    0\n```\n\n\n:::\n:::\n\n\n## Eigenvalues\n\nUntuk mencari nilai eigen, gunakan fungsi `eigen()` dan akses nilainya dengan `$values`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(c(4,2,2,2,4,2,2,2,4), ncol=3, byrow = TRUE)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    4    2    2\n[2,]    2    4    2\n[3,]    2    2    4\n```\n\n\n:::\n\n```{.r .cell-code}\neig_val <- eigen(A)$values\neig_val\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8 2 2\n```\n\n\n:::\n:::\n\n\n### Eigenvectors\n\nUntuk mencari vektor eigen dari nilai eigen yang bersesuaian, gunakan `$vectors`\n\n\n::: {.cell}\n\n```{.r .cell-code}\neig_vec <- eigen(A)$vectors * (-1) # Dikalikan dengan -1\neig_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          [,1]       [,2]       [,3]\n[1,] 0.5773503  0.0000000 -0.8164966\n[2,] 0.5773503  0.7071068  0.4082483\n[3,] 0.5773503 -0.7071068  0.4082483\n```\n\n\n:::\n:::\n\n\n## Dekomposisi Spectral\n\nDari eigenvalues dan eigenvector, dapat dibentuk suatu dekomposisi spektral dari suatu matriks.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(eig_vec %*% diag(eig_val) %*% t(eig_vec))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    4    2    2\n[2,]    2    4    2\n[3,]    2    2    4\n```\n\n\n:::\n:::\n\n\n## Dekomposisi Cholesky\n\nDekomposisi cholesky dari suatu matriks **A** dapat dilakukan dengan fungsi `chol(A)`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(c(3,0,-3,0,6,3,-3,3,6), ncol=3, byrow=T)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    3    0   -3\n[2,]    0    6    3\n[3,]   -3    3    6\n```\n\n\n:::\n\n```{.r .cell-code}\nchol(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         [,1]    [,2]      [,3]\n[1,] 1.732051 0.00000 -1.732051\n[2,] 0.000000 2.44949  1.224745\n[3,] 0.000000 0.00000  1.224745\n```\n\n\n:::\n:::\n\n\nSehingga dapat dibuktikan **A** = **U`U** dengan **U** matriks segitiga atas dari dekomposisi cholesky matriks **A**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt(chol(A)) %*% chol(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    3    0   -3\n[2,]    0    6    3\n[3,]   -3    3    6\n```\n\n\n:::\n:::\n\n\n## Singular Value Decomposition (SVD)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(c(1,0,1,0,1,0), ncol=3, byrow = TRUE)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    0    1\n[2,]    0    1    0\n```\n\n\n:::\n\n```{.r .cell-code}\nsvd_A <- svd(A)\n```\n:::\n\n\nNilai diagonal matriks **D** dapat diakses dengan `$d`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsvd_A$d\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.414214 1.000000\n```\n\n\n:::\n:::\n\n\nMatriks **U** dapat diakses dengan `$u`\n\n::: {.cell}\n\n```{.r .cell-code}\nsvd_A$u\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    0\n[2,]    0    1\n```\n\n\n:::\n:::\n\n\nMatriks **V** dapat diakses dengan `$v`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsvd_A$v\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          [,1] [,2]\n[1,] 0.7071068    0\n[2,] 0.0000000    1\n[3,] 0.7071068    0\n```\n\n\n:::\n:::\n\n\nSehingga dapat dibuktikan **A** = **UDV`**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsvd_A$u %*% diag(svd_A$d) %*% t(svd_A$v)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    0    1\n[2,]    0    1    0\n```\n\n\n:::\n:::\n\n\n## Ortogonalisasi Matrix (Gram-Schmidt)\n\nOrtogonalisasi matrix dengan proses Gram-Schmidt dapat dilakukan dengan fungsi `GramSchmidt()` dari library `matlib`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(c( 1:3, 3:1, 1, 0, -2), 3, 3)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    3    1\n[2,]    2    2    0\n[3,]    3    1   -2\n```\n\n\n:::\n\n```{.r .cell-code}\nGramSchmidt(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          [,1]       [,2]       [,3]\n[1,] 0.2672612  0.8728716 -0.4082483\n[2,] 0.5345225  0.2182179  0.8164966\n[3,] 0.8017837 -0.4364358 -0.4082483\n```\n\n\n:::\n:::\n\n\nBukti:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA_gs <- GramSchmidt(A)\nround(A_gs %*% t(A_gs))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    1    0\n[3,]    0    0    1\n```\n\n\n:::\n:::\n\n\n# Latihan Soal\n\nDiberikan matriks berikut\n\n![](static/latsol.png)\n\nCarilah nilai:\n\n1. 2.576 x (**A** + **B**)\n\n2. **Bx**\n\n3. **y`B**\n\n4. **x`Ay**\n\n5. Inner product dari **x** dan **x**\n\n6. Inner product dari **x** dan **y**\n\n7. Outer product dari **y** dan **y**\n\n8. Nilai eigen dari **A** menggunakan `eigen()$values` dan hitung tanpa bantuan kode. Apakah nilainya sama?\n\n9. Vektor eigen dari **A** menggunakan fungsi `eigen()$vectors` dan hitung tanpa bantuan kode. Apakah nilainya sama?\n\n10. Matriks **U**, **D** dan **V** dari singular value decomposition pada invers dari matriks **B**",
    "supporting": [
      "modul1_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}